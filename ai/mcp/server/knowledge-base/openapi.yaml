openapi: 3.0.3
info:
  title: Neo Knowledge Base MCP Server API
  description: |
    This API provides structured access to the Neo.mjs project's knowledge base. 
    It enables AI agents to build, query, and manage the vector database containing 
    source code, documentation, and learning materials.
  version: 1.0.0
  contact:
    name: Neo.mjs Project
    url: https://github.com/neomjs/neo
  license:
    name: MIT
    url: https://opensource.org/licenses/MIT

servers:
  - url: http://localhost:8003
    description: Local development server

tags:
  - name: Health
    description: Server health and status endpoints
  - name: Database
    description: Operations for managing the knowledge base lifecycle
  - name: "Database Lifecycle"
    description: "Tools for starting and stopping the database process"
  - name: Documents
    description: Operations for querying knowledge base documents

paths:
  /healthcheck:
    get:
      summary: Health Check
      operationId: healthcheck
      x-annotations:
        readOnlyHint: true
      description: |
        Verifies that the server is running and can successfully connect to the
        ChromaDB vector database.

        Use this tool as a first step to diagnose issues if other database-related
        tools are failing. It provides a quick status check on the server and its
        primary dependency.
      tags: [Health]
      responses:
        '200':
          description: Server is healthy and connected to the database.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HealthCheckResponse'
        '503':
          description: Service Unavailable. The server is running but cannot connect to the database.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'

  /db/manage:
    post:
      summary: Manage Database
      operationId: manage_database
      description: |
        Manages the lifecycle (start/stop) of the ChromaDB database instance.

        **Behavior:**
        - **Start:**
          - **Managed:** If no database is running on the configured port, this tool spawns a new process managed by this server. This process will be automatically cleaned up when the agent session ends.
          - **External:** If a database is already running, this tool simply confirms the connection. The server acts as a client and will NOT kill the database on exit.
        - **Stop:**
          - **Managed:** Stops the process spawned by this server.
          - **External:** **No effect.** The server cannot stop a database it did not start.

        **Multi-Agent / Swarm Recommendation:**
        For workflows involving multiple concurrent agents, it is **highly recommended** to start the database externally using `npm run ai:server` before starting the agents. This prevents unexpected disconnects for other agents when the "owner" agent exits.

        **When to Use:**
        - Use `action: start` if a `healthcheck` reveals that the database process is not running.
        - Use `action: stop` for debugging, forcing a restart, or freeing up resources.
      tags: ["Database Lifecycle"]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - action
              properties:
                action:
                  type: string
                  enum: [start, stop]
                  description: The action to perform.
      responses:
        '200':
          description: Operation completed successfully.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/DatabaseLifecycleResponse'
        '500':
          description: Operation failed.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'

  /db/data/manage:
    post:
      summary: Manage Knowledge Base Data
      operationId: manage_knowledge_base
      description: |
        Manages the content of the knowledge base.

        **Actions:**
        - **sync:** (Recommended) Full update. Creates the JSONL file from source and embeds it.
        - **create:** Generates the intermediate `ai-knowledge-base.jsonl` file only.
        - **embed:** Embeds the existing JSONL file into the vector database (diff-based).
        - **delete:** (Destructive) Permanently deletes the entire collection from ChromaDB.

        **When to Use:**
        - Use **sync** to update the database after code changes.
        - Use **delete** followed by **sync** for a clean rebuild.
      tags: [Database]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - action
              properties:
                action:
                  type: string
                  enum: [sync, create, embed, delete]
                  description: The management action to perform.
      responses:
        '200':
          description: Operation completed successfully.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SuccessResponse'
        '500':
          description: Operation failed.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'

  /documents/query:
    post:
      summary: Query Documents
      operationId: query_documents
      x-pass-as-object: true
      x-annotations:
        readOnlyHint: true
      description: |
        Performs a semantic search on the knowledge base using a natural language query.
        Returns a scored and ranked list of the most relevant source files.

        ## How to Use This Tool
        
        **Input:**
        - `query`: Natural language search query (1-10 words work best)
        - `type`: Optional filter by content type (all, blog, guide, src, example, ticket, release)
        
        **Output:**
        A ranked list of file paths with relevance scores. Example:
        ```
        Most relevant source files (by weighted score):
        - /path/to/relevant/file1.mjs (Score: 350)
        - /path/to/relevant/file2.md (Score: 210)
        - /path/to/relevant/file3.mjs (Score: 150)
        
        Top result: /path/to/relevant/file1.mjs
        ```
        
        ## How to Interpret Results
        
        1. **Start with the top result**: Always read the highest-scoring file first.
        2. **Scan the next 5-10 results**: Check both file types and scores.
        3. **Balance source and guides**: Read top 1-2 source files (.mjs) AND top 1-2 guides (.md).
           - `.mjs` files: Implementation details, actual code
           - `.md` files: Conceptual context, architectural rationale
        4. **Prioritize content types**:
           - `guide` and `src`: Current best practices and implementation
           - `blog`: Historical context (code examples may be outdated)
           - `example`: Concrete usage patterns
           - `ticket`: Can be historical context (**closed tickets**) or potential work items (**open tickets**). Distinguish between them carefully.
        
        ## Query Strategies

        ### The Discovery Pattern: Broad to Narrow
        When learning about a new concept or feature area:

        1.  **Start Broad:** Query foundational concepts first.
            - For high-level questions, consult `learn/tree.json` to identify key concepts.
            - Use terms like `"benefits"`, `"architecture"`, `"fundamentals"`.
            - Prioritize reading guides from top-level directories.

        2.  **Narrow to Specifics:** Use broad results to formulate targeted queries.
            - `query_documents(query='Button component examples')`
            - `query_documents(query='what is Neo.component.Base?')`

        3.  **Filter by Type:** Use the `type` parameter for focused results.
            - Conceptual: `type='guide'`
            - Usage examples: `type='example'`
            - Implementation: `type='src'`
            - Historical context: `type='ticket'` or `type='blog'`

        ## When Queries Return No Results

        If queries consistently return no relevant results for your task:

        **Pause and document the gap:**
        - Clearly describe what you were trying to accomplish
        - List the queries you attempted (show your work)
        - Explain why existing results were insufficient
        - Consult with the user about next steps

        **Before implementing based on assumptions:**
        - Explain the knowledge gap you've identified
        - Propose your approach and its basis (general software patterns, analogous Neo.mjs patterns, etc.)
        - Get explicit user approval to proceed

        ## Handling Failures
        
        If this tool fails or throws an error:
        1. Run the `healthcheck` tool to diagnose the issue.
        2. If unhealthy, consult `.github/AI_QUICK_START.md` for setup guidance.
      tags: [Documents]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/QueryRequest'
            examples:
              conceptual_query:
                summary: Broad Conceptual Query
                value:
                  query: "framework benefits and architecture"
              specific_component_query:
                summary: Specific Component Query
                value:
                  query: "Button component examples"
              targeted_guide_query:
                summary: Targeted Content-Type Query
                value:
                  query: "state management"
                  type: "guide"
              targeted_source_query:
                summary: Targeted Source Code Query
                value:
                  query: "afterSet hook"
                  type: "src"
      responses:
        '200':
          description: Successfully retrieved and scored query results.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/QueryResponse'
        '400':
          description: Bad Request. The request body is invalid.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'
        '500':
          description: Internal server error during query.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'

  /knowledge/ask:
    post:
      summary: Ask Knowledge Base (RAG)
      operationId: ask_knowledge_base
      x-pass-as-object: true
      description: |
        Performs a semantic search and uses an LLM to synthesize an answer based on the top results.
        Use this tool to get a high-level answer without manually reading multiple files.

        **Input:**
        - `query`: The question to ask.
        - `limit`: (Optional) Number of source documents to consider (default 5).
        - `type`: (Optional) Filter by content type (e.g., 'guide', 'src', 'all').

        **Output:**
        - `answer`: Synthesized answer.
        - `references`: List of source files used to generate the answer.
      tags: [Documents]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - query
              properties:
                query:
                  type: string
                  description: The question to ask.
                type:
                  type: string
                  description: "Optional filter by content type (e.g., 'guide', 'src', 'all')."
                  enum: [all, blog, guide, src, example, ticket, release, test]
                  default: all
                limit:
                  type: integer
                  description: Number of documents to include in context.
                  default: 5
      responses:
        '200':
          description: Successful RAG response.
          content:
            application/json:
              schema:
                type: object
                properties:
                  answer:
                    type: string
                  references:
                    type: array
                    items:
                      type: object
                      properties:
                        name:
                          type: string
                        source:
                          type: string
                        score:
                          type: number
        '500':
          description: Internal server error.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'

  /knowledge/hierarchy:
    get:
      summary: Get Class Hierarchy
      operationId: get_class_hierarchy
      x-pass-as-object: true
      x-annotations:
        readOnlyHint: true
      description: |
        Retrieves the static class hierarchy from the knowledge base.
        This tool provides a deterministic map of class relationships (inheritance) derived from source code.

        **Input:**
        - `root`: (Optional) Filter the hierarchy to show only subclasses of this class (e.g., 'Neo.component.Base').

        **Output:**
        A JSON object where keys are class names and values contain metadata (source file, parent class).
      tags: [Documents]
      parameters:
        - name: root
          in: query
          required: true
          description: The root class name to filter by.
          schema:
            type: string
            example: "Neo.component.Base"
      responses:
        '200':
          description: The class hierarchy map.
          content:
            application/json:
              schema:
                type: object
                additionalProperties:
                  type: string
                  nullable: true
        '404':
          description: Hierarchy file not found (requires sync).
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'
        '500':
          description: Internal server error.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'

  /documents:
    get:
      summary: List Documents
      operationId: list_documents
      x-pass-as-object: true
      x-annotations:
        readOnlyHint: true
      description: |
        Retrieves a paginated list of all documents from the knowledge base collection.

        **When to Use:**
        Use this tool for debugging or inspection to see the raw, chunked content that exists
        within the vector database. It can be useful for verifying the output of the
        `create` and `embed` processes.
      tags: [Documents]
      parameters:
        - name: limit
          in: query
          required: false
          description: The maximum number of documents to return.
          schema:
            type: integer
            default: 100
        - name: offset
          in: query
          required: false
          description: The number of documents to skip for pagination.
          schema:
            type: integer
            default: 0
      responses:
        '200':
          description: A paginated list of documents.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/DocumentListResponse'
        '500':
          description: Internal server error.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'

  /documents/{id}:
    get:
      summary: Get Document by ID
      operationId: get_document_by_id
      x-pass-as-object: true
      x-annotations:
        readOnlyHint: true
      description: |
        Retrieves a single document from the collection by its unique ID.

        **When to Use:**
        Use this tool to inspect a specific chunk of content from the database, for example,
        after it has been identified by a `query` or `list` operation.
      tags: [Documents]
      parameters:
        - name: id
          in: path
          required: true
          description: The unique ID of the document to retrieve.
          schema:
            type: string
      responses:
        '200':
          description: The requested document.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Document'
        '404':
          description: Document not found.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'
        '500':
          description: Internal server error.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'

components:
  schemas:
    HealthCheckResponse:
      type: object
      properties:
        status:
          type: string
          description: Overall health status of the server.
          enum: [healthy, degraded, unhealthy]
          example: "healthy"
        timestamp:
          type: string
          format: date-time
          description: Timestamp of when the health check was performed.
          example: "2025-10-25T12:00:00Z"
        database:
          type: object
          properties:
            process:
              type: object
              properties:
                running:
                  type: boolean
                  description: True if the ChromaDB process is running.
                  example: true
                pid:
                  type: integer
                  nullable: true
                  description: Process ID of the ChromaDB server, if running.
                  example: 12345
                managed:
                  type: boolean
                  description: True if the ChromaDB process is managed by this server.
                  example: true
            connection:
              type: object
              properties:
                connected:
                  type: boolean
                  description: True if the server can connect to ChromaDB.
                  example: true
                collections:
                  type: object
                  nullable: true
                  properties:
                    knowledgeBase:
                      type: object
                      properties:
                        name:
                          type: string
                          example: "neo-knowledge-base"
                        exists:
                          type: boolean
                          example: true
                        count:
                          type: integer
                          example: 1234
        features:
          type: object
          properties:
            embedding:
              type: boolean
              description: "Indicates if the embedding feature is available (requires GEMINI_API_KEY)."
              example: true
        details:
          type: array
          items:
            type: string
          description: "A list of human-readable details about the system's status."
          example:
            - "ChromaDB is running and all collections are accessible"
            - "All features are operational"
        version:
          type: string
          example: "1.0.0"
        uptime:
          type: number
          description: Server uptime in seconds.
          example: 3600

    DatabaseLifecycleResponse:
      type: object
      properties:
        status:
          type: string
          enum: [started, stopped, already_running, not_running]
        pid:
          type: integer
          nullable: true

    QueryRequest:
      type: object
      required:
        - query
      properties:
        query:
          type: string
          description: |
            Natural language search query. Best practices:
            - Keep queries concise (1-10 words)
            - Use specific technical terms when known
            - Start broad, then narrow based on results
            - Example good queries: "Button component", "state management patterns", 
              "afterSet hook implementation", "multi-window architecture"
          example: "How do I use the Tab Container component?"
        type:
          type: string
          description: |
            Filter results by content type:
            - `all`: Search all content (default)
            - `guide`: Conceptual explanations and architectural docs
            - `src`: Source code implementation
            - `example`: Working examples and demos
            - `blog`: Historical context and evolution (code may be outdated)
            - `ticket`: Issues from GitHub. Can be open (potential work) or closed (historical context).
            - `release`: Release notes and changelogs
            - `test`: Automated tests and specs
          enum: [all, blog, guide, src, example, ticket, release, test]
          default: all
        limit:
          type: integer
          description: The maximum number of results to return.
          default: 25

    QueryResultItem:
      type: object
      properties:
        source:
          type: string
          description: The file path of the relevant document.
        score:
          type: string
          description: The calculated relevance score.

    QueryResponse:
      type: object
      properties:
        topResult:
          type: string
          description: The file path of the highest-scoring result.
        results:
          type: array
          items:
            $ref: '#/components/schemas/QueryResultItem'

    Document:
      type: object
      properties:
        id:
          type: string
        metadata:
          type: object
        content:
          type: string

    DocumentListResponse:
      type: object
      properties:
        count:
          type: integer
        documents:
          type: array
          items:
            $ref: '#/components/schemas/Document'

    SuccessResponse:
      type: object
      properties:
        message:
          type: string
          example: "Operation completed successfully"
        details:
          type: string
          description: Optional details about the operation.
          example: "Knowledge base synchronization started."

    ErrorResponse:
      type: object
      properties:
        error:
          type: string
          example: "Database connection failed"
        message:
          type: string
          example: "Could not connect to ChromaDB at the specified address."
        code:
          type: string
          example: "DB_CONNECTION_ERROR"