import Base             from '../core/Base.mjs';
import DomAccess        from './DomAccess.mjs';
import {voidAttributes} from '../vdom/domConstants.mjs';

const NeoConfig = Neo.config;

/**
 * Logic to apply the deltas generated by vdom.Helper to the real DOM
 * @class Neo.main.DeltaUpdates
 * @extends Neo.core.Base
 * @singleton
 */
class DeltaUpdates extends Base {
    static config = {
        /**
         * @member {String} className='Neo.main.DeltaUpdates'
         * @protected
         */
        className: 'Neo.main.DeltaUpdates',
        /**
         * @member {Boolean} singleton=true
         */
        singleton: true
    }

    /**
     * Recursively creates a DOM element (or DocumentFragment) from a VNode tree.
     * This method is intended for initial mounting or for inserting new VNode subtrees
     * directly into the DOM without string serialization/parsing.
     *
     * @param {Object}                       vnode        The VNode object to convert to a real DOM element.
     * @param {DocumentFragment|HTMLElement} [parentNode] The parent DOM node to append the created element to.
     * If not provided, a DocumentFragment is used as a temporary root.
     * @returns {Comment|DocumentFragment|HTMLElement|null} The created DOM node or DocumentFragment.
     * @private
     */
    #createDomTree(vnode, parentNode) {
        let domNode;

        // No node or just a reference node, opt out
        if (!vnode || vnode.componentId) {
            return null
        }

        // Handle text nodes
        if (vnode.vtype === 'text') {
            domNode = document.createTextNode(vnode.textContent || '');

            // Wrap in comment for consistency with delta updates
            const
                commentStart = document.createComment(` ${vnode.id} `),
                commentEnd   = document.createComment(' /neo-vtext '),
                fragment     = document.createDocumentFragment();

            fragment.append(commentStart, domNode, commentEnd);
            domNode = fragment
        }
        // Handle regular elements
        else if (vnode.nodeName) {
            if (vnode.ns) { // For SVG, ensure correct namespace
                domNode = document.createElementNS(vnode.ns, vnode.nodeName)
            } else {
                domNode = document.createElement(vnode.nodeName)
            }

            // Apply the top-level 'id' property first (guaranteed to exist)
            domNode[NeoConfig.useDomIds ? 'id' : 'data-neo-id'] = vnode.id;

            // Apply Attributes
            Object.entries(vnode.attributes).forEach(([key, value]) => {
                if (voidAttributes.has(key)) {
                    domNode[key] = (value === 'true' || value === true)
                } else if (key === 'value') {
                    domNode.value = value
                } else if (value !== null && value !== undefined) {
                    domNode.setAttribute(key, value)
                }
            });

            // Apply Classes
            if (vnode.className.length > 0) {
                domNode.classList.add(...vnode.className)
            }

            // Apply Styles
            if (Neo.isObject(vnode.style)) {
                Object.entries(vnode.style).forEach(([key, value]) => {
                    let important;

                    if (Neo.isString(value) && value.includes('!important')) {
                        value = value.replace('!important', '').trim();
                        domNode.style.setProperty(Neo.decamel(key), value, 'important');
                        important = 'important'
                    }

                    domNode.style.setProperty(Neo.decamel(key), value, important)
                })
            }

            // Handle innerHTML & textContent
            // This applies to elements that contain only plain text (e.g., <span>Hello</span>)
            // If the VNode has childNodes, this block is skipped, and content is handled recursively.
            if (vnode.childNodes.length < 1) {
                if (vnode.innerHTML) {
                    domNode.innerHTML = vnode.innerHTML
                } else if (vnode.textContent) {
                    domNode.textContent = vnode.textContent
                }
            }
        } else {
            console.error('Unhandled VNode type or missing nodeName:', vnode);
            return null
        }

        // Recursively process children
        vnode.childNodes.forEach(childVnode => {
            this.#createDomTree(childVnode, domNode)
        })

        // Append to parent or return as fragment
        if (parentNode) {
            parentNode.append(domNode);
            return domNode
        } else {
            // If no parentNode was provided for the initial call,
            // return a DocumentFragment containing the top-level element.
            const fragment = document.createDocumentFragment();

            if (domNode) {
                fragment.appendChild(domNode)
            }

            return fragment
        }
    }

    /**
     * @param {HTMLElement} node
     * @param {String}      nodeName
     */
    changeNodeName(node, nodeName) {
        let {attributes} = node,
            clone        = document.createElement(nodeName),
            i            = 0,
            len          = attributes.length,
            attribute;

        if (node) {
            for (; i < len; i++) {
                attribute = attributes.item(i);
                clone.setAttribute(attribute.nodeName, attribute.nodeValue)
            }

            clone.innerHTML= node.innerHTML;

            node.parentNode.replaceChild(clone, node)
        }
    }

    /**
     * @param {Object} delta
     * @param {String} delta.id
     */
    focusNode({id}) {
        DomAccess.getElement(id)?.focus()
    }

    /**
     * @param {String} html representing a single element
     * @returns {ChildNode}
     */
    htmlStringToElement(html) {
        const template = document.createElement('template');
        template.innerHTML = html;
        return template.content
    }

    /**
     * Inserts a new node into the DOM tree based on delta updates.
     * This method handles both string-based (outerHTML) and direct DOM API (vnode) mounting.
     * It ensures the node is inserted at the correct index within the parent.
     *
     * Implementation Details & Considerations:
     * - `parentNode.children` contains only element nodes (tags).
     * - `parentNode.childNodes` contains all nodes, including text and comment nodes.
     * - Since every `vtype:'text'` is wrapped inside a comment block (as an ID),
     *   calculating a "realIndex" is necessary for string-based insertions to
     *   correctly account for non-element nodes.
     * - `insertAdjacentHTML()` is generally faster than creating a node via template,
     *   but it's only available for manipulating children (elements), not `childNodes` (all nodes).
     * - For performance, in cases where there are no comment nodes (i.e., no wrapped text nodes),
     *   the method prioritizes `insertAdjacentHTML()` when `useStringBasedMounting` is true.
     *
     * @param {Object}         delta
     * @param {Boolean}        delta.hasLeadingTextChildren Flag to honor leading comments, which require special treatment.
     * @param {Number}         delta.index                  The index at which to insert the new node within its parent.
     * @param {String}         [delta.outerHTML]            The string representation of the new node (for string-based mounting).
     * @param {String}         delta.parentId               The ID of the parent DOM node.
     * @param {Neo.vdom.VNode} [delta.vnode]                The VNode representation of the new node (for direct DOM API mounting).
     */
    insertNode({hasLeadingTextChildren, index, outerHTML, parentId, vnode}) {
        let me         = this,
            parentNode = DomAccess.getElementOrBody(parentId);

        if (parentNode) {
            // Direct DOM API mounting: create a DocumentFragment and insert it
            if (!NeoConfig.useStringBasedMounting) {
                let fragment = me.#createDomTree(vnode);

                // Can be null
                if (fragment) {
                    if (index < parentNode.childNodes.length) {
                        parentNode.insertBefore(fragment, parentNode.childNodes[index])
                    } else {
                        parentNode.appendChild(fragment)
                    }
                }

            // String-based mounting logic
            } else {
                me.#insertNodeAsString({parentNode, hasLeadingTextChildren, index, outerHTML})
            }
        }
    }

    /**
     * Handles string-based insertion of a new node into the DOM.
     * This method is called by `insertNode()` when `NeoConfig.useStringBasedMounting` is true.
     *
     * @param {Object}      data
     * @param {Boolean}     data.hasLeadingTextChildren Flag to honor leading comments.
     * @param {Number}      data.index                  The index at which to insert the new node.
     * @param {String}      data.outerHTML              The HTML string of the node to insert.
     * @param {HTMLElement} data.parentNode             The parent DOM node to insert into.
     * @private
     */
    #insertNodeAsString({hasLeadingTextChildren, index, outerHTML, parentNode}) {
        let me = this;

        // If comments detected, parse HTML string to a node and use insertBefore/appendChild on childNodes.
        if (hasLeadingTextChildren) {
            let node = me.htmlStringToElement(outerHTML);

            if (index < parentNode.childNodes.length) {
                parentNode.insertBefore(node, parentNode.childNodes[index])
            } else {
                parentNode.appendChild(node)
            }
        }
        // If no comments detected, use insertAdjacentHTML for element nodes.
        else {
            let countChildren = parentNode.children.length; // Use `children` for `insertAdjacentHTML` context

            if (index > 0 && index >= countChildren) {
                parentNode.insertAdjacentHTML('beforeend', outerHTML);
                return
            }
            if (countChildren > 0 && countChildren > index) {
                parentNode.children[index].insertAdjacentHTML('beforebegin', outerHTML)
            } else if (countChildren > 0) {
                parentNode.children[countChildren - 1].insertAdjacentHTML('afterend', outerHTML)
            } else {
                parentNode.insertAdjacentHTML('beforeend', outerHTML)
            }
        }
    }

    /**
     * Moves an existing DOM node to a new position within its parent
     * or to a new parent.
     * This method directly manipulates the DOM using the pre-calculated physical index.
     *
     * @param {Object} delta
     * @param {String} delta.id       The ID of the DOM node to move.
     * @param {Number} delta.index    The physical index at which to insert the node
     * @param {String} delta.parentId The ID of the target parent DOM node.
     */
    moveNode({id, index, parentId}) {
        let node       = DomAccess.getElement(id),
            parentNode = DomAccess.getElement(parentId);

        if (node && parentNode) {
            // If the target index is at or beyond the end of the parent's current childNodes, append the node.
            if (index >= parentNode.childNodes.length) {
                parentNode.appendChild(node)
            } else {
                // Get the reference node at the target physical index.
                let referenceNode = parentNode.childNodes[index];

                // Only proceed if the node is not already at its target position.
                if (node !== referenceNode) {
                    // Perform a direct swap operation if immediate element siblings.
                    if (node.nodeType === 1 && node === referenceNode.nextElementSibling) {
                        node.replaceWith(referenceNode)
                    }

                    parentNode.insertBefore(node, referenceNode)
                }
            }
        }
    }

    /**
     * @param {Object} delta
     * @param {String} delta.parentId
     */
    removeAll({parentId}) {
        let node = DomAccess.getElement(parentId);

        if (node) {
            node.innerHTML = ''
        }
    }

    /**
     * @param {Object} delta
     * @param {String} delta.id
     * @param {String} delta.parentId
     */
    removeNode({id, parentId}) {
        const node = DomAccess.getElement(id);

        if (node) {
            node.remove();
        }
        // Potentially a vtype: 'text' node (wrapped between 2 comments)
        else if (parentId) {
            const
                parentNode = DomAccess.getElementOrBody(parentId),
                isComment  = Node.COMMENT_NODE;

            if (parentNode) {
                // Find the starting comment node using its id marker
                const startComment = Array.from(parentNode.childNodes).find(n =>
                    n.nodeType === isComment && n.nodeValue.includes(` ${id} `)
                );

                if (startComment) {
                    const
                        textNode = startComment.nextSibling,
                        // Ensure endComment is a comment node before attempting to remove
                        endComment = textNode?.nextSibling?.nodeType === isComment ? textNode.nextSibling : null;

                    // Remove the three parts: start comment, text node, end comment
                    startComment.remove();
                    textNode?.remove();
                    endComment?.remove()
                }
            }
        }
    }

    /**
     * @param {Object} delta
     * @param {String} delta.fromId
     * @param {String} delta.parentId
     * @param {String} delta.toId
     */
    replaceChild({fromId, parentId, toId}) {
        let node = DomAccess.getElement(parentId);

        node?.replaceChild(DomAccess.getElement(toId), DomAccess.getElement(fromId))
    }

    /**
     * @param {Object} delta
     * @param {String} [delta.id]
     * @param {String} [delta.value
     */
    setTextContent({id, value}) {
        let node = DomAccess.getElement(id);

        if (node) {
            node.textContent = value
        }
    }

    /**
     * @param {Object} delta
     * @param {Object} [delta.attributes]
     * @param {String} [delta.cls]
     * @param {String} [delta.id]
     * @param {String} [delta.innerHTML]
     * @param {String} [delta.outerHTML]
     * @param {Object} [delta.style]
     */
    updateNode(delta) {
        let me   = this,
            node = DomAccess.getElementOrBody(delta.id);

        if (!node) {
            console.log('node not found', delta.id);
        }

        if (node) {
            Object.entries(delta).forEach(([prop, value]) => {
                switch(prop) {
                    case 'attributes':
                        Object.entries(value).forEach(([key, val]) => {
                            if (voidAttributes.has(key)) {
                                node[key] = val === 'true' // vnode attribute values get converted into strings
                            } else if (val === null || val === '') {
                                if (key === 'value') {
                                    node[key] = '' // input fields => pseudo attribute can not be removed
                                } else {
                                    node.removeAttribute(key)
                                }
                            } else if (key === 'id') {
                                node[NeoConfig.useDomIds ? 'id' : 'data-neo-id'] = val
                            } else if (key === 'spellcheck' && val === 'false') {
                                // see https://github.com/neomjs/neo/issues/1922
                                node[key] = false
                            } else {
                                if (key === 'value') {
                                    node[key] = val
                                } else {
                                    node.setAttribute(key, val)
                                }
                            }
                        });
                        break
                    case 'cls':
                        value.add    && node.classList.add(...value.add);
                        value.remove && node.classList.remove(...value.remove);
                        break
                    case 'innerHTML':
                        node.innerHTML = value || '';
                        break
                    case 'nodeName':
                        me.changeNodeName(node, value);
                        break
                    case 'outerHTML':
                        node.outerHTML = value || '';
                        break
                    case 'style':
                        if (Neo.isObject(value)) {
                            Object.entries(value).forEach(([key, val]) => {
                                let important;

                                if (Neo.isString(val) && val.includes('!important')) {
                                    val = val.replace('!important', '').trim();
                                    important = 'important'
                                }

                                node.style.setProperty(Neo.decamel(key), val, important)
                            })
                        }
                        break
                }
            })
        }
    }

    /**
     * @param {Object} delta
     * @param {String} delta.id
     * @param {String} delta.parentId
     * @param {String} delta.value
     */
    updateVtext({id, parentId, value}) {
        let node      = DomAccess.getElement(parentId),
            innerHTML = node.innerHTML,
            startTag  = `<!-- ${id} -->`,
            reg       = new RegExp(startTag + '[\\s\\S]*?<!-- \/neo-vtext -->');

        node.innerHTML = innerHTML.replace(reg, value)
    }

    /**
     * @param {Object} data
     * @param {Object|Object[]} data.deltas
     * @param {String} data.id
     * @param {String} [data.origin='app']
     */
    update(data) {
        let me       = this,
            {deltas} = data,
            i        = 0,
            len;

        deltas = Array.isArray(deltas) ? deltas : [deltas];
        len    = deltas.length;

        if (NeoConfig.logDeltaUpdates && len > 0) {
            me.countDeltas += len;
            me.countUpdates++;
            console.log('update ' + me.countUpdates, 'total deltas ', me.countDeltas, Neo.clone(data, true))
        }

        if (NeoConfig.renderCountDeltas && len > 0) {
            me.countDeltasPer250ms += len
        }

        for (; i < len; i++) {
            me[deltas[i].action || 'updateNode'](deltas[i])
        }

        Neo.worker.Manager.sendMessage(data.origin || 'app', {
            action : 'reply',
            replyId: data.id,
            success: true
        })
    }
}

export default Neo.setupClass(DeltaUpdates);
