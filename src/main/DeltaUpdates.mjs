import Base             from '../core/Base.mjs';
import DomAccess        from './DomAccess.mjs';
import {voidAttributes} from '../vdom/domConstants.mjs';

const NeoConfig = Neo.config;

/**
 * Manages and applies the Virtual DOM (VDom) delta updates generated by `Neo.vdom.Helper` to the real browser DOM.
 * This class acts as the bridge between the VDom worker's calculated changes and the actual rendering on the main thread.
 * It orchestrates various DOM manipulation operations such as node insertions, removals, moves, attribute updates,
 * and handles dynamic renderer switching based on `Neo.config.useDomApiRenderer`.
 *
 * As a singleton per browser window, it provides a centralized and efficient mechanism for synchronized DOM updates,
 * ensuring the UI accurately reflects the application state.
 * @class Neo.main.DeltaUpdates
 * @extends Neo.core.Base
 * @singleton
 */
class DeltaUpdates extends Base {
    static config = {
        /**
         * @member {String} className='Neo.main.DeltaUpdates'
         * @protected
         */
        className: 'Neo.main.DeltaUpdates',
        /**
         * @member {Number} countDeltas=0
         * @protected
         */
        countDeltas: 0,
        /**
         * @member {Number} countDeltasPer250ms=0
         * @protected
         */
        countDeltasPer250ms: 0,
        /**
         * @member {Number} countUpdates=0
         * @protected
         */
        countUpdates: 0,
        /**
         * @member {Boolean} renderCountDeltas_=false
         * @protected
         * @reactive
         */
        renderCountDeltas_: false,
        /**
         * @member {Boolean} singleton=true
         */
        singleton: true
    }

    /**
     * @member {Number} logDeltasIntervalId=0
     * @protected
     */
    logDeltasIntervalId = 0
    /**
     * @member {Boolean|null} nativeMoveBefore=null
     * @protected
     */
    nativeMoveBefore = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let {environment} = NeoConfig;

        if (NeoConfig.renderCountDeltas) {
            this.renderCountDeltas = true
        }

        // We need different publicPath values for the main thread inside the webpack based dist envs,
        // depending on the hierarchy level of the app entry point
        if (environment === 'dist/development' || environment === 'dist/production') {
            __webpack_require__.p = NeoConfig.basePath.substring(6)
        }
    }

    /**
     * Triggered after the renderCountDeltas config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetRenderCountDeltas(value, oldValue) {
        let me                    = this,
            {logDeltasIntervalId} = me,
            node;

        if (value) {
            if (logDeltasIntervalId === 0) {
                me.logDeltasIntervalId = setInterval(() => {
                    node = document.getElementById('neo-delta-updates');

                    if (node) {
                        node.innerHTML = String(me.countDeltasPer250ms * 4)
                    }

                    me.countDeltasPer250ms = 0
                }, 250)
            }
        } else {
            logDeltasIntervalId && clearInterval(logDeltasIntervalId);
            me.logDeltasInterval = 0
        }
    }

    /**
     * Changes the tag name (nodeName) of an existing HTMLElement in the DOM.
     * This operation is performed by creating a new HTML element with the desired `nodeName`,
     * meticulously copying all attributes and the `innerHTML` from the original `node` to the new one,
     * and then seamlessly replacing the original `node` with the newly created element within its parent.
     *
     * @param {HTMLElement} node     The existing DOM HTMLElement whose tag name needs to be changed.
     * @param {String}      nodeName The new tag name (e.g., 'div', 'span', 'p') for the element.
     */
    changeNodeName(node, nodeName) {
        let {attributes} = node,
            clone        = document.createElement(nodeName),
            i            = 0,
            len          = attributes.length,
            attribute;

        if (node) {
            for (; i < len; i++) {
                attribute = attributes.item(i);
                clone.setAttribute(attribute.nodeName, attribute.nodeValue)
            }

            while (node.firstChild) {
                clone.appendChild(node.firstChild)
            }

            if (node.value !== undefined && node.value !== clone.value) {
                clone.value = node.value
            }

            if (node.checked !== undefined && node.checked !== clone.checked) {
                clone.checked = node.checked
            }

            if (node.selectedIndex !== undefined && node.selectedIndex !== clone.selectedIndex) {
                clone.selectedIndex = node.selectedIndex
            }

            if (node.scrollTop > 0) {
                clone.scrollTop = node.scrollTop
            }

            if (node.scrollLeft > 0) {
                clone.scrollLeft = node.scrollLeft
            }

            node.parentNode.replaceChild(clone, node)
        }
    }

    /**
     *
     */
    checkRendererAvailability() {
        const {render} = Neo.main;

        if (NeoConfig.useDomApiRenderer) {
            if (!render?.DomApiRenderer) {
                throw new Error('Neo.main.DeltaUpdates: DomApiRenderer is not loaded yet!')
            }
        } else {
            if (!render?.StringBasedRenderer) {
                throw new Error('Neo.main.DeltaUpdates: StringBasedRenderer is not loaded yet!')
            }
        }
    }

    /**
     * @param {Object} delta
     * @param {String} delta.id
     */
    focusNode({id}) {
        DomAccess.getElement(id)?.focus()
    }

    /**
     * Imports either (if not already imported):
     * `Neo.main.render.DomApiRenderer`      if Neo.config.useDomApiRenderer === true
     * `Neo.main.render.StringBasedRenderer` if Neo.config.useDomApiRenderer === false
     * @returns {Promise<void>}
     * @protected
     */
    async importRenderer() {
        const {render} = Neo.main;

        if (NeoConfig.useDomApiRenderer) {
            if (!render?.DomApiRenderer) {
                await import('./render/DomApiRenderer.mjs')
            }
        } else {
            if (!render?.StringBasedRenderer) {
                await import('./render/StringBasedRenderer.mjs')
            }
        }
    }

    /**
     * @returns {Promise<void>}
     */
    async initAsync() {
        super.initAsync();

        let me = this;

        // Subscribe to global Neo.config changes for dynamic renderer switching.
        Neo.worker.Manager.on({
            neoConfigChange: me.onNeoConfigChange,
            scope          : me
        });

        await me.importRenderer()
    }

    /**
     * Helper to retrieve the start anchor comment of a Fragment using XPath.
     * Fragments are rendered as a range anchored by `<!-- id-start -->` and `<!-- id-end -->`.
     * @param {String} id The Fragment ID
     * @returns {Comment|null}
     */
    getFragmentStart(id) {
        const xpath = `//comment()[.=' ${id}-start ']`;
        return document.evaluate(xpath, document.body, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue
    }

    /**
     * Helper to calculate the reference sibling for insertion *inside* a Fragment's DOM range.
     * Since a Fragment is not a real DOM parent, we must traverse its siblings to find the correct
     * insertion point relative to the Start Anchor.
     *
     * @param {Node} startNode The Fragment start anchor
     * @param {Number} index The logical index (relative to fragment content)
     * @param {Node} [nodeToSkip] Optional node to skip during traversal (e.g. the node being moved)
     * @returns {Node|null} The node to insert before, or null (append)
     */
    getFragmentSibling(startNode, index, nodeToSkip) {
        let currentNode = startNode.nextSibling,
            i           = 0;

        // Traverse 'index' steps.
        // If index is 0, we want nextSibling (insert after start).
        // If index is 1, we want nextSibling.nextSibling.
        while (currentNode && i < index) {
            if (currentNode !== nodeToSkip) {
                i++
            }

            currentNode = currentNode.nextSibling
        }

        return currentNode
    }

    /**
     * Helper to retrieve all DOM nodes belonging to a Fragment.
     * This walks the DOM from the Start Anchor until it hits the End Anchor, collecting all intermediate nodes.
     * This is used for moving or removing the entire Fragment range.
     *
     * @param {HTMLElement} parentNode
     * @param {String}      id
     * @returns {Object|null} {startNode, endNode, nodes: []}
     */
    getFragmentNodes(parentNode, id) {
        if (!parentNode) return null;

        const
            isComment = Node.COMMENT_NODE,
            startStr  = ` ${id}-start `;

        let startNode = Array.from(parentNode.childNodes).find(n =>
            n.nodeType === isComment && n.nodeValue === startStr
        );

        // Fallback for text nodes (if we want to unify, though text nodes use ` id `)
        // For now, let's strictly handle Fragments here.

        if (!startNode) return null;

        const
            endStr = ` ${id}-end `,
            nodes  = [];

        let currentNode = startNode.nextSibling;

        while (currentNode) {
            // Check if we hit the end anchor
            if (currentNode.nodeType === isComment && currentNode.nodeValue === endStr) {
                return {startNode, endNode: currentNode, nodes};
            }

            nodes.push(currentNode);
            currentNode = currentNode.nextSibling
        }

        return null // End anchor not found (should not happen in healthy DOM)
    }

    /**
     * Inserts a new node into the DOM tree based on delta updates.
     * This method handles both string-based (outerHTML) and direct DOM API (vnode) mounting.
     * It ensures the node is inserted at the correct index within the parent.
     * This method is synchronous and *expects* the appropriate renderer (DomApiRenderer or StringBasedRenderer) to be already loaded.
     *
     * @param {Object}         delta
     * @param {Boolean}        delta.hasLeadingTextChildren Flag to honor leading comments, which require special treatment.
     * @param {Number}         delta.index                  The index at which to insert the new node within its parent.
     * @param {String}         [delta.outerHTML]            The string representation of the new node (for string-based mounting).
     * @param {String}         delta.parentId               The ID of the parent DOM node.
     * @param {Object[]}       [delta.postMountUpdates]     Array of post-mount updates (e.g. scroll state).
     * @param {Neo.vdom.VNode} [delta.vnode]                The VNode representation of the new node (for direct DOM API mounting).
     */
    insertNode({hasLeadingTextChildren, index, outerHTML, parentId, postMountUpdates, vnode}) {
        this.checkRendererAvailability();

        let {render}   = Neo.main,
            parentNode = DomAccess.getElement(parentId),
            siblingRef;

        // 1. Resolve Target Parent & Sibling
        if (!parentNode) {
            const startNode = this.getFragmentStart(parentId);
            if (startNode) {
                parentNode = startNode.parentNode;
                siblingRef = this.getFragmentSibling(startNode, index)
            }
        } else {
            siblingRef = parentNode.childNodes[index]
        }

        if (parentNode) {
            let localPostMountUpdates = [],
                newNode;

            if (NeoConfig.useDomApiRenderer) {
                newNode = render.DomApiRenderer.createDomTree({
                    index           : -1,
                    isRoot          : true,
                    parentNode      : null, // detached
                    postMountUpdates: localPostMountUpdates,
                    vnode
                })
            } else {
                newNode = render.StringBasedRenderer.createNode({outerHTML});

                if (postMountUpdates?.length > 0) {
                    localPostMountUpdates.push(...postMountUpdates)
                }
            }

            if (newNode) {
                parentNode.insertBefore(newNode, siblingRef || null);

                if (localPostMountUpdates.length > 0) {
                    localPostMountUpdates.forEach(update => {
                        // DomApiRenderer format: {node, vnode}
                        if (update.node) {
                            if (update.vnode.scrollLeft) {update.node.scrollLeft = update.vnode.scrollLeft}
                            if (update.vnode.scrollTop)  {update.node.scrollTop  = update.vnode.scrollTop}
                        }
                        // StringBasedRenderer format: {id, scrollLeft, scrollTop}
                        else {
                            let node = DomAccess.getElement(update.id);

                            if (node) {
                                if (update.scrollLeft) {node.scrollLeft = update.scrollLeft}
                                if (update.scrollTop)  {node.scrollTop  = update.scrollTop}
                            }
                        }
                    })
                }
            } else {
                console.error('insertNode: Failed to create newNode', {outerHTML, vnode});
            }
        } else {
            console.error('insertNode: Parent not found', {parentId, index});
        }
    }

    /**
     * Inserts a batch of new nodes into the DOM tree.
     * This optimization groups contiguous 'insertNode' deltas targeting the same parent
     * into a single DocumentFragment insertion, minimizing browser reflows.
     *
     * @param {Object[]} batch Array of delta objects to insert.
     * @protected
     */
    insertNodeBatch(batch) {
        const
            firstDelta = batch[0],
            parentId   = firstDelta.parentId,
            index      = firstDelta.index;

        let parentNode = DomAccess.getElement(parentId),
            siblingRef;

        // 1. Resolve Target Parent & Sibling
        if (!parentNode) {
            const startNode = this.getFragmentStart(parentId);
            if (startNode) {
                parentNode = startNode.parentNode;
                siblingRef = this.getFragmentSibling(startNode, index)
            }
        } else {
            siblingRef = parentNode.childNodes[index]
        }

        if (parentNode) {
            const
                fragment            = document.createDocumentFragment(),
                {render}            = Neo.main,
                allPostMountUpdates = [];

            batch.forEach(delta => {
                let localPostMountUpdates = delta.postMountUpdates || [],
                    node;

                if (NeoConfig.useDomApiRenderer) {
                    node = render.DomApiRenderer.createDomTree({
                        index           : -1,
                        isRoot          : true,
                        parentNode      : null, // detached
                        postMountUpdates: localPostMountUpdates,
                        vnode           : delta.vnode
                    })
                } else {
                    node = render.StringBasedRenderer.createNode({outerHTML: delta.outerHTML})
                }

                if (node) {
                    fragment.appendChild(node);
                    if (localPostMountUpdates.length > 0) {
                        allPostMountUpdates.push(...localPostMountUpdates)
                    }
                } else {
                    console.error('insertNodeBatch: Failed to create node', delta);
                }
            });

            parentNode.insertBefore(fragment, siblingRef || null);

            // Apply all post-mount updates (e.g. scroll positions) after the batch insertion
            if (allPostMountUpdates.length > 0) {
                allPostMountUpdates.forEach(update => {
                    // DomApiRenderer format: {node, vnode}
                    if (update.node) {
                        if (update.vnode.scrollLeft) {update.node.scrollLeft = update.vnode.scrollLeft}
                        if (update.vnode.scrollTop)  {update.node.scrollTop  = update.vnode.scrollTop}
                    }
                    // StringBasedRenderer format: {id, scrollLeft, scrollTop}
                    else {
                        let node = DomAccess.getElement(update.id);

                        if (node) {
                            if (update.scrollLeft) {node.scrollLeft = update.scrollLeft}
                            if (update.scrollTop)  {node.scrollTop  = update.scrollTop}
                        }
                    }
                })
            }
        } else {
            console.error('insertNodeBatch: Parent not found', {parentId, index});
        }
    }

    /**
     * Move an existing DOM node to a new position within its parent or to a new parent.
     * This method directly manipulates the DOM using the pre-calculated physical index,
     * accounting for potential text nodes wrapped in comments.
     *
     * **Atomic Moves & Focus Preservation:**
     * If the browser supports `Element.moveBefore()`, it is used to atomically move the node
     * without losing state (focus, iframe content, etc.).
     *
     * **Legacy Fallback:**
     * For browsers without `moveBefore` (e.g. Safari), it falls back to `insertBefore` (or `replaceWith`).
     * Since reparenting causes focus loss in these environments, it manually restores focus
     * immediately after the move.
     *
     * **Fragment Support:**
     * If the target `id` refers to a Fragment (which has no single DOM node), this method uses XPath
     * to find the "Start Anchor", extracts the full range of nodes (Start...End) into a `DocumentFragment`,
     * and moves that lightweight wrapper to the new location.
     *
     * @param {Object} delta
     * @param {String} delta.id       The ID of the DOM node to move.
     * @param {Number} delta.index    The physical index at which to insert the node within the target parent's childNodes.
     * @param {String} delta.parentId The ID of the target parent DOM node.
     */
    moveNode({id, index, parentId}) {
        let node       = DomAccess.getElement(id),
            parentNode = DomAccess.getElement(parentId),
            siblingRef;

        // 1. Resolve Target Parent & Sibling
        if (!parentNode) {
            const startNode = this.getFragmentStart(parentId);
            if (startNode) {
                parentNode = startNode.parentNode;
                siblingRef = this.getFragmentSibling(startNode, index)
            }
        } else {
            // Standard parent: resolve sibling by index
            if (node && node.parentNode === parentNode) {
                // Check if we are moving forward in the same parent.
                // If so, the current node is taking up an index, shifting our target.
                const currentIndex = Array.prototype.indexOf.call(parentNode.childNodes, node);

                if (currentIndex > -1 && currentIndex < index) {
                    index++
                }
            }

            if (index < parentNode.childNodes.length) {
                siblingRef = parentNode.childNodes[index]
            } else {
                siblingRef = null // Append
            }
        }

        // 2. Resolve Node to Move (Fragment fallback)
        if (!node && parentNode) {
            const
                xpath     = `//comment()[.=' ${id}-start ']`,
                startNode = document.evaluate(xpath, document.body, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;

            if (startNode) {
                const fragmentData = this.getFragmentNodes(startNode.parentNode, id);

                if (fragmentData) {
                    const fragment = document.createDocumentFragment();
                    fragment.append(fragmentData.startNode, ...fragmentData.nodes, fragmentData.endNode);
                    node = fragment
                }
            }
        }

        if (node && parentNode) {
            // Only proceed if the node is not already at its target position.
            // Note: For DocumentFragments (nodeType 11), we always move, as the fragment wrapper is transient.
            if (node !== siblingRef) {
                if (this.nativeMoveBefore === null) {
                    this.nativeMoveBefore = typeof parentNode.moveBefore === 'function'
                }

                if (this.nativeMoveBefore) {
                    parentNode.moveBefore(node, siblingRef || null)
                } else {
                    const
                        activeElement = document.activeElement,
                        containsFocus = activeElement && (node === activeElement || node.contains(activeElement));

                    // Perform a direct swap operation if immediate element siblings.
                    if (node.nodeType === 1 && siblingRef && node === siblingRef.nextElementSibling) {
                        node.replaceWith(siblingRef)
                    }

                    parentNode.insertBefore(node, siblingRef || null);

                    if (containsFocus) {
                        activeElement.focus()
                    }
                }
            }
        }
    }

    /**
     * Handler for global Neo.config changes.
     * If the `Neo.config.useDomApiRenderer` value changes, this method dynamically loads the renderer.
     * @param {Object} config
     * @return {Promise<void>}
     */
    async onNeoConfigChange(config) {
        if (Object.hasOwn(config, 'useDomApiRenderer')) {
            await this.importRenderer()
        }
    }

    /**
     * Helper to retrieve all DOM nodes belonging to a Fragment (or Text Node range).
     * @param {HTMLElement} parentNode
     * @param {String}      id
     * @returns {Object|null} {startNode, endNode, nodes: []}
     */
    getFragmentNodes(parentNode, id) {
        if (!parentNode) return null;

        const
            isComment = Node.COMMENT_NODE,
            startStr  = ` ${id}-start `;

        let startNode = Array.from(parentNode.childNodes).find(n =>
            n.nodeType === isComment && n.nodeValue === startStr
        );

        // Fallback for text nodes (if we want to unify, though text nodes use ` id `)
        // For now, let's strictly handle Fragments here.

        if (!startNode) return null;

        const
            endStr = ` ${id}-end `,
            nodes  = [];

        let currentNode = startNode.nextSibling;

        while (currentNode) {
            // Check if we hit the end anchor
            if (currentNode.nodeType === isComment && currentNode.nodeValue === endStr) {
                return {startNode, endNode: currentNode, nodes};
            }

            nodes.push(currentNode);
            currentNode = currentNode.nextSibling
        }

        return null // End anchor not found (should not happen in healthy DOM)
    }

    /**
     * Clears all child nodes of a given parent DOM node.
     * This is achieved by setting its `innerHTML` property to an empty string,
     * which is generally considered the fastest and most efficient way to remove
     * all children from a DOM element in modern browsers.
     *
     * @param {Object} delta
     * @param {String} delta.parentId The ID of the parent DOM node whose children will be removed.
     */
    removeAll({parentId}) {
        let node = DomAccess.getElement(parentId);

        if (node) {
            node.innerHTML = ''
        }
    }

    /**
     * Removes a DOM node from its parent.
     * This method handles both standard HTML elements and virtual text nodes,
     * which are typically wrapped within comment nodes in the DOM.
     *
     * @param {Object} delta
     * @param {String} delta.id       The ID of the DOM node to remove.
     * @param {String} delta.parentId The ID of the parent DOM node (required for text node removal).
     */
    removeNode({id, parentId}) {
        const node = DomAccess.getElement(id);

        if (node) {
            node.remove();
        }
        // Potentially a vtype: 'text' node or a Fragment (wrapped between 2 comments)
        else if (parentId) {
            const parentNode = DomAccess.getElementOrBody(parentId);

            if (parentNode) {
                // 1. Try Fragment Removal
                const fragmentData = this.getFragmentNodes(parentNode, id);

                if (fragmentData) {
                    fragmentData.startNode.remove();
                    fragmentData.endNode.remove();
                    fragmentData.nodes.forEach(n => n.remove());
                    return
                }

                // 2. Text Node Logic
                const isComment = Node.COMMENT_NODE;

                // Find the starting comment node using its id marker
                const startComment = Array.from(parentNode.childNodes).find(n =>
                    n.nodeType === isComment && n.nodeValue.includes(` ${id} `)
                );

                if (startComment) {
                    const
                        textNode = startComment.nextSibling,
                        // Ensure endComment is a comment node before attempting to remove
                        endComment = textNode?.nextSibling?.nodeType === isComment ? textNode.nextSibling : null;

                    // Remove the three parts: start comment, text node, end comment
                    startComment.remove();
                    textNode?.remove();
                    endComment?.remove()
                }
            }
        }
    }

    /**
     * Replaces an existing child DOM node (`fromId`) with a new DOM node (`toId`)
     * within a specified parent DOM node (`parentId`).
     * This operation directly invokes the native `Node.replaceChild()` API,
     * performing an atomic swap of the elements in the DOM tree.
     * It is typically used when a specific DOM element needs to be completely
     * exchanged for a different one at the same position.
     *
     * @param {Object} delta
     * @param {String} delta.fromId   The ID of the existing child DOM node to be replaced.
     * @param {String} delta.parentId The ID of the parent DOM node containing the child to be replaced.
     * @param {String} delta.toId     The ID of the new DOM node that will replace the old one.
     */
    replaceChild({fromId, parentId, toId}) {
        let node = DomAccess.getElement(parentId);

        node?.replaceChild(DomAccess.getElement(toId), DomAccess.getElement(fromId))
    }

    /**
     * Updates various properties of an existing DOM node based on the provided delta.
     * This includes updating attributes, class names, inner HTML, node name, and inline styles.
     * It handles specific cases for attribute types (e.g., boolean attributes, 'value')
     * and style properties (e.g., '!important').
     *
     * @param {Object} delta
     * @param {String} delta.id            The ID of the DOM node to update.
     * @param {Object} [delta.attributes]  An object containing attribute key-value pairs to update or remove (if value is null/empty).
     * @param {Object} [delta.cls]         An object containing 'add' and/or 'remove' arrays for CSS classes.
     * @param {String} [delta.innerHTML]   The new inner HTML content for the node.
     * @param {String} [delta.nodeName]    The new tag name for the node (will trigger a node replacement).
     * @param {String} [delta.outerHTML]   The new outer HTML content for the node (will trigger a node replacement).
     * @param {Object} [delta.style]       An object containing CSS style properties to update. Values can include '!important'.
     * @param {String} [delta.textContent] The new text content for the node (replaces innerHTML if present).
     */
    updateNode(delta) {
        let me   = this,
            node = DomAccess.getElementOrBody(delta.id);

        if (node) {
            Object.entries(delta).forEach(([prop, value]) => {
                switch (prop) {
                    case 'attributes':
                        Object.entries(value).forEach(([key, val]) => {
                            if (voidAttributes.has(key)) {
                                node[key] = val === 'true' // vnode attribute values get converted into strings
                            } else if (val === null || val === '') {
                                if (key === 'value') {
                                    node[key] = '' // input fields => pseudo attribute can not be removed
                                } else {
                                    node.removeAttribute(key)
                                }
                            } else if (key === 'id') {
                                node[NeoConfig.useDomIds ? 'id' : 'data-neo-id'] = val
                            } else if (key === 'spellcheck' && val === 'false') {
                                // see https://github.com/neomjs/neo/issues/1922
                                node[key] = false
                            } else {
                                if (key === 'value') {
                                    node[key] = val
                                } else {
                                    node.setAttribute(key, val)
                                }
                            }
                        });
                        break
                    case 'cls':
                        value.add    && node.classList.add(...value.add);
                        value.remove && node.classList.remove(...value.remove);
                        break
                    case 'innerHTML':
                        node.innerHTML = value || '';
                        break
                    case 'nodeName':
                        me.changeNodeName(node, value);
                        break
                    case 'outerHTML':
                        node.outerHTML = value || '';
                        break
                    case 'scrollLeft':
                    case 'scrollTop':
                        node[prop] = value;
                        break
                    case 'style':
                        if (Neo.isObject(value)) {
                            Object.entries(value).forEach(([key, val]) => {
                                let important;

                                if (Neo.isString(val) && val.includes('!important')) {
                                    val = val.replace('!important', '').trim();
                                    important = 'important'
                                }

                                node.style.setProperty(Neo.decamel(key), val, important)
                            })
                        }
                        break
                    case 'textContent':
                        node.textContent = value;
                        break
                }
            })
        }
    }

    /**
     * Updates the text content of a virtual text node within the DOM.
     * Virtual text nodes are rendered within the DOM as a pair of HTML comments,
     * with their content embedded between them. This method locates the specific
     * text node by its ID (embedded in the start comment tag) within its parent's
     * innerHTML and replaces its content using a regular expression.
     *
     * @param {Object} delta
     * @param {String} delta.id       The unique ID of the virtual text node, which is embedded in its opening comment tag.
     * @param {String} delta.parentId The ID of the parent DOM node whose `innerHTML` contains the virtual text node.
     * @param {String} delta.value    The new text content to be applied to the virtual text node.
     */
    updateVtext({id, parentId, value}) {
        const
            node      = DomAccess.getElement(parentId),
            isComment = Node.COMMENT_NODE,
            idString  = ` ${id} `;

        if (node) {
            const startComment = Array.from(node.childNodes).find(n =>
                n.nodeType === isComment && n.nodeValue === idString
            );

            if (startComment?.nextSibling) {
                startComment.nextSibling.nodeValue = value
            }
        }
    }

    /**
     * Applies a set of VDom delta updates to the real DOM.
     * This method is the core entry point for rendering changes initiated from the VDom worker.
     * It iterates through the provided deltas and dispatches them to specific DOM manipulation
     * methods (e.g., insertNode, removeNode, updateNode) based on their `action` property.
     * This method expects the appropriate renderer (DomApiRenderer or StringBasedRenderer)
     * to be loaded based on `Neo.config.useDomApiRenderer`.
     *
     * @param {Object} data
     * @param {Object|Object[]} data.deltas An array of delta objects, or a single delta object,
     * representing changes to be applied to the DOM.
     * Each delta object contains an `action` property
     * (e.g., 'insertNode', 'removeNode', 'updateNode', 'moveNode')
     * and additional properties relevant to the specific action.
     * @param {String} data.id             The unique ID of the request, used for sending a reply back to the origin.
     * @param {String} [data.origin='app'] The origin of the message (e.g., 'app'), used for sending replies.
     */
    update(data) {
        this.checkRendererAvailability();

        let me       = this,
            {deltas} = data,
            i        = 0,
            len;

        deltas = Array.isArray(deltas) ? deltas : [deltas];
        len    = deltas.length;

        if (NeoConfig.logDeltaUpdates && len > 0) {
            me.countDeltas += len;
            me.countUpdates++;
            console.log('update ' + me.countUpdates, 'total deltas ', me.countDeltas, Neo.clone(data, true))
        }

        if (NeoConfig.renderCountDeltas && len > 0) {
            me.countDeltasPer250ms += len
        }

        while (i < len) {
            const delta = deltas[i];

            // Batching optimization for sequential insertNode operations
            if (delta.action === 'insertNode' && i < len - 1) {
                let j     = i + 1,
                    batch = [delta];

                while (j < len) {
                    const
                        nextDelta = deltas[j],
                        prevDelta = deltas[j - 1];

                    if (
                        nextDelta.action === 'insertNode' &&
                        nextDelta.parentId === delta.parentId &&
                        nextDelta.index === prevDelta.index + 1 // Ensure sequential indices
                    ) {
                        batch.push(nextDelta);
                        j++
                    } else {
                        break
                    }
                }

                if (batch.length > 1) {
                    me.insertNodeBatch(batch);
                    i = j; // Skip the processed batch
                    continue
                }
            }

            // Fallback for non-batched operations
            me[delta.action || 'updateNode'](delta);
            i++
        }
    }
}

export default Neo.setupClass(DeltaUpdates);