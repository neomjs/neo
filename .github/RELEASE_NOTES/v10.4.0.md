# Neo.mjs v10.4.0 Release Notes

## Highlights

This release focuses heavily on performance and robustness, especially when dealing with very large datasets in collections, stores, and grids. Key improvements include non-blocking chunked data loading for stores, a fix for stack overflow errors when adding large arrays to collections, and significant optimizations for grid scrolling and data clearing.

## Enhancements

### 1. High-Performance Chunking for `Store.add()`
To prevent the UI from freezing when adding massive datasets (e.g., 1M+ records), `Store.add()` now uses a two-chunk loading strategy. It first adds a small "interactive" batch of records to make the UI responsive almost instantly. It then silently adds the remaining data in the background by leveraging the `suspendEvents` flag, and fires a final `load` event to update the UI (e.g., grid scrollbars) once complete. This ensures a non-blocking, highly responsive user experience.

### 2. Refactored Grid ScrollManager for Smoother Scrolling
The `grid.ScrollManager` has been refactored to use the framework's built-in `delayable` system instead of manual `setTimeout` logic. Both vertical and horizontal scroll event handlers are now throttled to align with a 60fps refresh rate, and a debounced `onBodyScrollEnd` handler efficiently manages the `isScrolling` state. This results in smoother scrolling, more consistent behavior, and cleaner, more maintainable code.

### 3. Grid `onStoreLoad` Fast Path for Instant Clearing
A performance "fast path" has been added to the `grid.Body` for scenarios where a store is cleared. Instead of performing a full VDOM diff between the existing rows and an empty dataset, the grid now detects this specific case and directly clears the VDOM and the real DOM. This reduces the time to clear a large grid from ~13ms to a near-instantaneous operation.

## Bug Fixes

### 1. Fixed `collection.Base#splice` Stack Overflow
A `RangeError: Maximum call stack size exceeded` would occur when adding a very large number of items (e.g., >100k) to an already populated collection at runtime. This was caused by using the spread operator (`...`) on a massive array. The `splice` method now intelligently switches to a safer `concat()`-based approach for large arrays, preventing the crash while retaining the high performance of native `splice` for smaller arrays.

### 2. Fixed `collection.Base#construct` Race Condition
A race condition was fixed where methods on a collection could be called during instantiation before the collection's internal properties were initialized. The `construct` method's logic was reordered to ensure all internal properties are defined *before* the parent constructor is called, making the class more robust and preventing subtle bugs during component initialization.
