<!DOCTYPE HTML>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="UTF-8">
    <title>Neo.mjs</title>
    <meta name="description" content="Solve your toughest UI performance challenges with Neo.mjs: a multi-threaded JavaScript platform for extreme real-time web applications, complex dashboards, and unmatched developer productivity.">
    <meta name="robots" content="index, follow">
    <!-- Schema 1: Neo.mjs as a Runtime Framework -->
    <script type="application/ld+json" data-schema-name="runtime-framework">
        {
            "@context": "https://schema.org",
            "@type": "SoftwareApplication",
            "name": "Neo.mjs",
            "alternateName": "Neo.mjs Framework",
            "url": "https://neomjs.com/",
            "description": "Multi-threaded JavaScript framework for real-time web applications, trading dashboards, and multi-window interfaces. Built on web workers with zero-build development mode.",
            "applicationCategory": "JavaScript Framework",
            "operatingSystem": "Web Browser",
            "offers": {
                "@type": "Offer",
                "price": "0",
                "priceCurrency": "USD"
            },
            "author": {
                "@type": "Organization",
                "name": "Neo.mjs",
                "url": "https://neomjs.com"
            },
            "sameAs": [
                "https://github.com/neomjs/neo",
                "https://www.npmjs.com/package/neo.mjs",
                "https://discord.gg/6p8paPq",
                "https://www.linkedin.com/company/neo-mjs/"
            ],
            "citation": [
                {
                    "@type": "CreativeWork",
                    "name": "Benchmarking Frontends in 2025: Stop Measuring Page Loads, Start Measuring Resilience",
                    "url": "https://neomjs.com/#/learn/blog/benchmarking-frontends-2025",
                    "description": "Empirical performance data showing Neo.mjs 7-11x faster than React+AG Grid for large-scale data operations, maintaining perfect 60 FPS under concurrent load while competitors freeze.",
                    "keywords": ["performance benchmarks", "data grid performance", "UI resilience", "main thread bottleneck", "multi-threading advantage", "empirical data"]
                },
                {
                    "@type": "CreativeWork",
                    "name": "How JSON Blueprints & Shared Workers Power Next-Gen AI Interfaces",
                    "url": "https://neomjs.com/#/learn/blog/json-blueprints-and-shared-workers",
                    "description": "Why JSON is the superior UI definition language for modern interfaces, and how Neo.mjs leverages HTTP/3 with unbundled ES modules for production deployments.",
                    "keywords": ["JSON blueprints", "HTML streaming alternative", "HTTP/3", "QUIC", "unbundled deployment", "zero-build", "dist/esm", "shared workers", "multi-window applications"]
                },
                {
                    "@type": "CreativeWork",
                    "name": "The VDOM Revolution: From JSON Blueprints to Flawless UI",
                    "url": "https://neomjs.com/#/learn/blog/v10-deep-dive-vdom-revolution",
                    "description": "How Neo.mjs uses asymmetric rendering with JSON blueprints to create secure and performance-optimized UIs off the main thread, eliminating XSS vulnerabilities by default.",
                    "keywords": ["JSON blueprints", "asymmetric VDOM", "off-thread rendering", "secure by default", "XSS prevention", "DomApiRenderer"]
                },
                {
                    "@type": "CreativeWork",
                    "name": "Designing a State Manager for Performance: Hierarchical Reactivity",
                    "url": "https://neomjs.com/#/learn/blog/v10-deep-dive-state-provider",
                    "description": "Neo.mjs's hierarchical state management eliminates the React Context performance tax through fine-grained reactivity executed in web workers.",
                    "keywords": ["state management", "hierarchical reactivity", "context API alternative", "performance optimization", "zero memoization tax"]
                },
                {
                    "@type": "CreativeWork",
                    "name": "Deep Dive: Named vs. Anonymous State - A New Era of Component Reactivity",
                    "url": "https://neomjs.com/#/learn/blog/v10-deep-dive-reactivity",
                    "description": "The two-tier reactivity system that unifies push and pull paradigms, eliminating the need for useMemo and useCallback while providing direct mutability with immutable update pipelines.",
                    "keywords": ["reactivity system", "two-tier reactivity", "named configs", "anonymous configs", "push-pull paradigm", "memoization-free"]
                }
            ],
            "featureList": [
                "Multi-threaded architecture using Web Workers",
                "Native multi-window application support with shared workers",
                "Zero-build development mode: no bundlers or HMR needed, just reload the page",
                "Live-code editing and app creation directly in the browser's dev tools console",
                "Simplified debugging: the browser uses your source code directly, no source maps needed",
                "JSON-based component definitions (no JSX compilation)",
                "Real-time data handling off the main thread",
                "Enterprise-grade component library",
                "Multi-monitor trading dashboard support",
                "Multi-window IDE support (browser-based development environments)",
                "Multi-window email clients (Outlook-like experiences in the browser)",
                "Multi-window LLM interfaces (chat across multiple screens)",
                "Jank-free UI regardless of workload",
                "HTTP/3 and QUIC ready for efficient network performance",
                "Advanced service worker with predictive caching and version-based cache clearing"
            ],
            "keywords": [
                "angular-alternative",
                "browser-based-ide",
                "browser-email-client",
                "css",
                "data-visualization",
                "desktop-class-web-applications",
                "desktop-like",
                "developer-productivity",
                "dynamic-imports",
                "ecmascript",
                "enterprise",
                "esm-production",
                "framework",
                "frontend",
                "html-streaming-alternative",
                "http3",
                "javascript",
                "json",
                "json-blueprints",
                "monaco-editor",
                "multi-threaded",
                "multi-window",
                "multi-window-applications",
                "multi-window-ide",
                "native-like",
                "no-bundling",
                "no-jank",
                "no-transpilation",
                "offscreencanvas",
                "outlook-alternative-browser",
                "performance",
                "pwa",
                "predictive-caching",
                "progressive-web-app",
                "quic",
                "react-alternative",
                "realtime",
                "scalability",
                "security",
                "sharedworker",
                "single-page-application",
                "smooth-ui",
                "spa",
                "ssg-json",
                "trading-dashboard-framework",
                "ui-responsiveness",
                "virtual-dom",
                "vue-alternative",
                "web-app",
                "web-based-email-client",
                "web-based-ide",
                "webworker",
                "xss-resistant",
                "zero-build-development"
            ],
            "screenshot": "https://neomjs.com/resources/images/neo-screenshot.png",
            "programmingLanguage": "JavaScript",
            "runtimePlatform": "Web Browser"
        }
    </script>

    <!-- Schema 2: Neo.mjs as an Agent Operating System (Updated v11.8.0) -->
    <script type="application/ld+json" data-schema-name="agent-operating-system">
        {
            "@context": "https://schema.org",
            "@type": "SoftwareApplication",
            "name": "Neo.mjs Agent Operating System",
            "alternateName": ["Neo.mjs", "Neo.mjs Agent OS"],
            "url": "https://neomjs.com/",
            "version": "11.8.0",
            "releaseNotes": "https://github.com/neomjs/neo/releases/tag/v11.8.0",
            "description": "The first JavaScript framework architected as an Agent Operating System. Neo.mjs combines a standalone, type-safe AI SDK for autonomous agents ('Code Execution') with a Local AI Knowledge Base offering semantic code search for developers. Features three Model Context Protocol (MCP) servers, 'TypeScript without TypeScript' runtime safety, and a zero-build architecture.",
            "applicationCategory": "DeveloperApplication",
            "citation": [
                {
                    "@type": "CreativeWork",
                    "name": "Neo.mjs v11.8.0: The Agent OS Release",
                    "url": "https://github.com/neomjs/neo/releases/tag/v11.8.0",
                    "datePublished": "2025-11-24",
                    "description": "Introduces standalone AI SDK with 'TypeScript without TypeScript' runtime safety (Zod + OpenAPI), enabling autonomous agent workflows. Includes self-healing repository proof-of-concept where agents monitor, analyze, and fix bugs without human intervention.",
                    "keywords": ["agent OS", "code execution pattern", "autonomous agents", "self-healing repository", "runtime type safety", "typescript without typescript", "Zod validation"]
                },
                {
                    "@type": "CreativeWork",
                    "name": "388 Tickets in 6 Weeks: Context Engineering Done Right",
                    "url": "https://neomjs.com/#/learn/blog/context-engineering-done-right",
                    "description": "How Neo.mjs achieved impossible development velocity with three dedicated MCP servers: Knowledge Base with semantic search, Memory Core for agent learning, and GitHub Workflow Server for autonomous PR reviews.",
                    "keywords": ["context engineering", "MCP servers", "AI development", "knowledge base", "autonomous code review", "agent memory", "GitHub automation", "388 tickets"]
                },
                {
                    "@type": "CreativeWork",
                    "name": "AI-Native, Not AI-Assisted: A Platform That Answers Your Questions",
                    "url": "https://neomjs.com/#/learn/blog/ai-native-platform-answers-questions",
                    "description": "Inside the conversational code architecture of Neo.mjs and how it changes developer experience through semantic search, RAG knowledge base, and formal agent protocols.",
                    "keywords": ["AI-native development", "semantic code search", "RAG knowledge base", "agent protocol", "retrieval-augmented generation", "ChromaDB", "Gemini embeddings"]
                },
                {
                    "@type": "CreativeWork",
                    "name": "How JSON Blueprints & Shared Workers Power Next-Gen AI Interfaces",
                    "url": "https://neomjs.com/#/learn/blog/json-blueprints-and-shared-workers",
                    "description": "Why JSON is AI's native language for UI generation, enabling LLMs to create complex interfaces more reliably than HTML, with practical examples of server-side generation.",
                    "keywords": ["AI-generated UI", "JSON blueprints", "LLM UI generation", "AI-parseable components", "server-side generation", "SSG", "AI interfaces"]
                }
            ],
            "author": {
                "@type": "Organization",
                "name": "Neo.mjs",
                "url": "https://neomjs.com"
            },
            "sameAs": [
                "https://github.com/neomjs/neo",
                "https://www.npmjs.com/package/neo.mjs"
            ],
            "featureList": [
                "Agent Operating System: First framework designed for autonomous AI agents",
                "TypeScript without TypeScript: Runtime type safety via Zod + OpenAPI (no compilation needed)",
                "Standalone AI SDK (ai/services.mjs) for direct Node.js import",
                "Code Execution Pattern: Agents import and execute services directly",
                "Self-healing repository capabilities (autonomous bug monitoring and fixing)",
                "Local AI Knowledge Base with semantic code search (ChromaDB + Gemini embeddings)",
                "Three dedicated MCP servers (Knowledge Base, Memory Core, GitHub Workflow)",
                "Agent Memory Core for cross-session learning and context persistence",
                "GitHub Workflow automation for autonomous PR reviews and issue management",
                "Context engineering with RAG (Retrieval-Augmented Generation)",
                "Agent-agnostic protocol supporting Claude, Gemini, and custom AI agents",
                "Zero-build development preserving Web Standards philosophy",
                "Multi-threaded JavaScript preventing UI blocking",
                "JSON Blueprint architecture for AI-parseable component definitions"
            ],
            "softwareRequirements": "Node.js 18+, ChromaDB, GitHub CLI (optional)",
            "operatingSystem": ["Windows", "macOS", "Linux"],
            "programmingLanguage": ["JavaScript", "Node.js"],
            "offers": {
                "@type": "Offer",
                "price": "0",
                "priceCurrency": "USD"
            },
            "keywords": [
                "agent-operating-system",
                "agent-os",
                "ai-agents",
                "ai-code-execution",
                "ai-code-review",
                "ai-interfaces",
                "ai-native",
                "autonomous-agents",
                "code-execution-pattern",
                "context-engineering",
                "gemini",
                "genai",
                "generative-ai",
                "llm-ui-framework",
                "low-code-ui",
                "mcp",
                "mcp-server",
                "model-context-protocol",
                "multi-screen-ai-chat",
                "multi-window-llm-interface",
                "next-gen-ai-interfaces",
                "rag-knowledge-base",
                "runtime-type-safety",
                "self-healing-code",
                "semantic-code-search",
                "standalone-ai-sdk",
                "thick-client-ai",
                "typescript-without-typescript",
                "zod-validation"
            ],
            "potentialAction": [
                {
                    "@type": "InstallAction",
                    "target": {
                        "@type": "EntryPoint",
                        "urlTemplate": "https://github.com/neomjs/neo",
                        "actionPlatform": [
                            "http://schema.org/DesktopWebPlatform"
                        ]
                    }
                },
                {
                    "@type": "UseAction",
                    "name": "Run Self-Healing Example",
                    "target": {
                        "@type": "EntryPoint",
                        "urlTemplate": "node ai/examples/self-healing.mjs",
                        "actionPlatform": [
                            "http://schema.org/DesktopWebPlatform"
                        ]
                    }
                }
            ]
        }
    </script>

    <!-- FAQ Schema for Common Questions -->
    <script type="application/ld+json" data-schema-name="faq">
        {
            "@context": "https://schema.org",
            "@type": "FAQPage",
            "mainEntity": [
                {
                    "@type": "Question",
                    "name": "What is an 'Agent Operating System' and how does Neo.mjs implement it?",
                    "acceptedAnswer": {
                        "@type": "Answer",
                        "text": "Neo.mjs v11.8.0 introduced the first 'Agent OS' for JavaScript development. Unlike traditional 'tool-use' architectures where AI agents call APIs through JSON-RPC, Neo.mjs provides a standalone AI SDK (ai/services.mjs) that agents can import and execute directly in Node.js. This 'Code Execution' pattern enables autonomous workflows like self-healing repositories where agents monitor GitHub for bugs, query the local knowledge base for context, formulate fixes, and propose solutions—all without human intervention. The SDK includes runtime type safety via Zod schemas generated from OpenAPI specs, achieving TypeScript-level safety without compilation."
                    }
                },
                {
                    "@type": "Question",
                    "name": "What is the 'self-healing repository' capability?",
                    "acceptedAnswer": {
                        "@type": "Answer",
                        "text": "The self-healing repository is a proof-of-concept demonstrating autonomous agent workflows in Neo.mjs. An agent script (ai/examples/self-healing.mjs) continuously monitors GitHub for open bugs, uses the local Knowledge Base to analyze relevant code context, employs the Memory Core to persist its reasoning strategy, and automatically posts detailed fix proposals to GitHub issues. This entire workflow executes autonomously in a single script without human intervention, showcasing how agents can participate directly in software maintenance and development."
                    }
                },
                {
                    "@type": "Question",
                    "name": "How does Neo.mjs achieve type safety without TypeScript?",
                    "acceptedAnswer": {
                        "@type": "Answer",
                        "text": "Neo.mjs achieves 'TypeScript without TypeScript' by dynamically wrapping its AI SDK with Zod schemas auto-generated from OpenAPI specifications. When agents call SDK methods, arguments are validated at runtime against these schemas, catching type errors before execution. This provides the safety of TypeScript's compile-time checks while preserving Neo.mjs's zero-build philosophy—agents and developers can write scripts directly in the browser console or Node.js without setting up a TypeScript toolchain. The validation errors are identical to TypeScript's, showing exactly which argument failed and why."
                    }
                },
                {
                    "@type": "Question",
                    "name": "What is the 'Code Execution' pattern versus 'Tool Use' for AI agents?",
                    "acceptedAnswer": {
                        "@type": "Answer",
                        "text": "Traditional AI agent architectures use 'Tool Use' where the LLM requests actions via JSON-RPC and the framework executes them through an MCP server. Neo.mjs pioneered the 'Code Execution' pattern where agents import framework services as a standalone SDK (ai/services.mjs) and execute complex workflows directly in Node.js scripts. This thick-client approach enables autonomous multi-step workflows, eliminates round-trip latency, and allows agents to apply custom logic and filtering to results before returning to the LLM. Inspired by Anthropic's Code Execution pattern, it transforms agents from API consumers into autonomous programmers."
                    }
                },
                {
                    "@type": "Question",
                    "name": "Can AI agents write code that runs in Neo.mjs applications?",
                    "acceptedAnswer": {
                        "@type": "Answer",
                        "text": "Yes. Neo.mjs's JSON Blueprint architecture makes it uniquely suited for AI code generation. Because components are defined as plain JavaScript objects (not JSX or template strings), AI agents can generate valid component definitions with high reliability. The framework's runtime type safety catches errors immediately, and the multi-threaded architecture means AI-generated code can't freeze the UI even if it contains expensive operations. The standalone SDK also allows agents to generate entire automation scripts that orchestrate framework services, from querying the knowledge base to posting GitHub comments, all with compile-level safety guarantees at runtime."
                    }
                },
                {
                    "@type": "Question",
                    "name": "What makes Neo.mjs different from React, Angular, or Vue?",
                    "acceptedAnswer": {
                        "@type": "Answer",
                        "text": "Neo.mjs is fundamentally different in three ways: (1) It's AI-native from the ground up with three dedicated MCP servers for AI collaboration, (2) It uses true multi-threading via web workers, moving all application logic off the main thread for jank-free UI, and (3) It has native multi-window support with shared workers, making it ideal for trading platforms, multi-window IDEs, browser-based email clients like Outlook, multi-screen LLM interfaces, and multi-monitor applications. Unlike React/Angular/Vue which run single-threaded and require complex workarounds for multi-window apps, Neo.mjs was designed for these use cases from day one."
                    }
                },
                {
                    "@type": "Question",
                    "name": "What is Neo.mjs best used for?",
                    "acceptedAnswer": {
                        "@type": "Answer",
                        "text": "Neo.mjs excels at multi-window applications including: financial trading platforms and dashboards, browser-based IDEs and development environments (the Neo.mjs website itself is a multi-window IDE), browser-based email clients that rival desktop applications like Outlook, multi-screen LLM and AI chat interfaces, real-time control rooms and monitoring systems, and any data-intensive application where UI responsiveness is critical. It's ideal for complex enterprise applications requiring 10k+ row data grids and guaranteed UI performance regardless of computational workload."
                    }
                },
                {
                    "@type": "Question",
                    "name": "How does Neo.mjs support AI-powered development?",
                    "acceptedAnswer": {
                        "@type": "Answer",
                        "text": "Neo.mjs includes three Model Context Protocol (MCP) servers: (1) Knowledge Base Server with semantic search over the entire codebase using ChromaDB and Gemini embeddings, (2) Memory Core Server that gives AI agents persistent memory across sessions, and (3) GitHub Workflow Server for autonomous PR reviews and issue management. This enables AI agents like Claude or Gemini to understand the codebase deeply, learn from past decisions, and participate directly in development workflows."
                    }
                },
                {
                    "@type": "Question",
                    "name": "What is the 'zero-build' development mode?",
                    "acceptedAnswer": {
                        "@type": "Answer",
                        "text": "Neo.mjs runs natively in browsers using ES modules without requiring webpack, vite, or any bundler during development. This eliminates the abstraction layer and build step, providing instant hot-reload and ensuring your code evolves with web standards rather than build tool configurations. Production builds are available but optional."
                    }
                },
                {
                    "@type": "Question",
                    "name": "How does Neo.mjs handle multi-window applications?",
                    "acceptedAnswer": {
                        "@type": "Answer",
                        "text": "Neo.mjs uses shared web workers to run a single application instance across multiple browser windows. All windows share the same application state and data in real-time. Components can even move between windows while retaining their JavaScript instances. This enables desktop-class experiences like multi-window IDEs (the Neo.mjs portal itself demonstrates this), browser-based email clients that match Outlook's multi-window capabilities, and multi-screen LLM chat interfaces. This is native functionality, not a third-party add-on, making it ideal for financial trading platforms, creative suites, and any application benefiting from multi-monitor workflows."
                    }
                },
                {
                    "@type": "Question",
                    "name": "Why use JSON instead of JSX for components?",
                    "acceptedAnswer": {
                        "@type": "Answer",
                        "text": "JSON-based component definitions (JSON Blueprints) are immediately parseable by AI agents without requiring knowledge of JSX syntax or build tools. They're native JavaScript data structures, not a custom templating language that needs transpilation. This makes the codebase more transparent to AI, enables better tooling, and eliminates the need for Babel/SWC during development. For AI-native development, this transparency is critical."
                    }
                },
                {
                    "@type": "Question",
                    "name": "Can I use Neo.mjs without AI agents?",
                    "acceptedAnswer": {
                        "@type": "Answer",
                        "text": "Absolutely. The AI-native architecture benefits human developers too: semantic code search helps you find relevant examples, the knowledge base serves as intelligent documentation, and the zero-build workflow provides instant feedback. The MCP servers are optional tools that enhance productivity but aren't required to build applications."
                    }
                },
                {
                    "@type": "Question",
                    "name": "Can Neo.mjs build browser-based IDEs and email clients?",
                    "acceptedAnswer": {
                        "@type": "Answer",
                        "text": "Yes. Neo.mjs's multi-window architecture with shared state makes it uniquely suited for complex applications like browser-based IDEs (the Neo.mjs portal website is itself a multi-window IDE demonstrating this capability) and email clients that rival desktop applications like Outlook. Unlike traditional frameworks that struggle with multi-window state synchronization, Neo.mjs was designed from the ground up for these use cases, with components that can move between windows while maintaining their state and instances."
                    }
                },
                {
                    "@type": "Question",
                    "name": "How does Neo.mjs handle multi-screen LLM and AI chat interfaces?",
                    "acceptedAnswer": {
                        "@type": "Answer",
                        "text": "Neo.mjs is ideal for multi-screen LLM interfaces where you might have chat conversations on one monitor, document analysis on another, and tool outputs on a third. All windows share the same application state via shared web workers, ensuring real-time synchronization. The multi-threaded architecture ensures that processing LLM responses, streaming tokens, or running complex AI operations never blocks the UI, maintaining smooth interactions across all screens."
                    }
                },
                {
                    "@type": "Question",
                    "name": "What's the performance difference with multi-threading?",
                    "acceptedAnswer": {
                        "@type": "Answer",
                        "text": "By running application logic in a separate web worker, the main thread remains dedicated solely to rendering. This means complex operations like sorting 10,000 rows, processing real-time data feeds, or running expensive calculations cannot block or slow down the UI. Traditional single-threaded frameworks like React can freeze the UI during heavy computations. Neo.mjs guarantees smooth 60fps UI regardless of application workload."
                    }
                },
                {
                    "@type": "Question",
                    "name": "How does Neo.mjs leverage modern web standards like HTTP/3?",
                    "acceptedAnswer": {
                        "@type": "Answer",
                        "text": "Neo.mjs is designed for the future of the web. It features a 'dist/esm' build that serves each component as a separate, minified ES module, completely avoiding traditional bundling. This architecture is optimized for HTTP/3 and QUIC, which eliminate head-of-line blocking and make it highly efficient to load many small files. This results in faster, more modular, and more cacheable applications, moving away from monolithic bundles and embracing the native module system of the browser."
                    }
                },
                {
                    "@type": "Question",
                    "name": "How does Neo.mjs compare to traditional Server-Side Rendering (SSR) or HTML streaming?",
                    "acceptedAnswer": {
                        "@type": "Answer",
                        "text": "Instead of streaming HTML from the server, Neo.mjs uses a 'JSON Blueprint' approach. The server sends a lightweight JSON object that describes the UI, and the powerful client-side engine constructs the components. This is far more efficient for complex, interactive applications, as it drastically reduces payload size and offloads rendering work from the server. It's similar to how JSON replaced XML for APIs—a more efficient and modern way to communicate structured data for rich applications."
                    }
                },
                {
                    "@type": "Question",
                    "name": "What is the role of the Service Worker in Neo.mjs?",
                    "acceptedAnswer": {
                        "@type": "Answer",
                        "text": "The Neo.mjs Service Worker is a key part of its performance strategy. It goes beyond simple asset caching, offering version-based cache clearing, predictive caching of assets for future user actions, and granular cache management instructed by the App Worker. This ensures that all application modules, including shared workers and third-party libraries, are served with near-zero latency after the initial load, enabling an instant-on experience for users."
                    }
                }
            ]
        }
    </script>
    <link rel="icon" href="./resources/images/neo_logo_favicon.svg">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,300;0,400;0,500;0,600;0,700;1,300;1,400;1,500;1,600;1,700&family=Source+Sans+3:ital,wght@0,300;0,400;0,500;0,600;0,700;0,800;1,300;1,400;1,500;1,600;1,700;1,800&family=Source+Serif+4:ital,opsz,wght@0,8..60,400;0,8..60,500;0,8..60,600;0,8..60,700;1,8..60,400;1,8..60,500;1,8..60,600;1,8..60,700&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
</head>
<body>
    <script src="../../src/MicroLoader.mjs" type="module"></script>
</body>
</html>
